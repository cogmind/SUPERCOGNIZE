<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="600" height="500" style="border:1px solid
#c3c3c3;">
Your browser does not support the HTML5 canvas tag.
</canvas>

<script type="text/javascript" src="AllPairwiseCombinations.js"></script> 
<script type="text/javascript">

//   window.write("<p>Hello</>");

    var iti = 500;
    //DEBUG
    //var iti = 20000;
    var sessions = 100; //DEBUG
    var count = 0;
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.fillStyle = "#7F7F7F";
	ctx.fillRect(0,0,600,500);
    const xsquareSize = 10;
    const ysquareSize = 10;
    var x = 100;
    var y = 100;
    var squareSize = 26;
    var retrievedCoordinates = [];
    const X = 0;
    const Y = 1;
    var expTimer = window.setInterval(displayStimulus, iti);
    var nSquares = 8; //INIT

    //TODO
    //replace timer with

    ///https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval#Example
    // (function loop(){
    //    setTimeout(function() {
    //       // Your logic here

    //       loop();
    //   }, delay);
    // })();
    var experimentColors = {
            RED: "#FF0000",
            BLUE: "#0000FF",
            MAGENTA: "#FF00FF",
            GREEN: "#00FF00",
            YELLOW: "#FFFF00",
            ORANGE: "#FF7F00",
            SKY_BLUE: "#007FFF",
            NIGHT_SKY_BLUE: "#00647F",
            DARK_ORANGE: "#7F6400",
            CYAN: "#00FFFF",
            DARK_RED: "#7F0000",
            DARK_GREEN: "#007F00",
            DARK_BLUE: "#00007F",
            DARK_MAGENTA: "#7F007F",
            DARK_YELLOW: "#7F7F00",
            PINK: "#FF007F",
            VIOLET: "#7F00FF"
    };

    console.log("(C) Copyright 2015. Daniel Labbé\nRunning experiment...");//Firebug debug output

    function endSession(reason) {
        reason = "Session ended due to: ".concat(reason);
        //alert(reason);
        
    }

    function displayStimulus() {

        //TRIAL

        //Background
        clearCanvas(ctx, c);
        ctx.fillStyle = "#7F7F7F";
        ctx.fillRect(0,0,600,500);

        count++;
        if (count == sessions) {
            window.clearInterval(expTimer);
            endSession("Timeout");
        }



        /**for (i = 0; i < 5; i++) {**/


		//

       
        retrievedCoordinates = getCoordinates(nSquares);
        //console.log(coordinates);


        var retrievedColors = pickUniqueRandomSetOfColors(nSquares);

        for (i = 0; i < nSquares; i++) {
            ctx.fillStyle = retrievedColors[i];
            ctx.fillRect(retrievedCoordinates[i][X], retrievedCoordinates[i][Y], squareSize, squareSize);
            ///DEBUG
            //ctx.fillStyle = "#FFFFFF";
            //ctx.fillRect(coordinates[i][X]+12, coordinates[i][Y]+12, 2, 2);
            //Demonstrates that the midpoint is in the upper left corner
            //ctx.fillRect(retrievedCoordinates[i][X], retrievedCoordinates[i][Y], 2, 2);

            //DATA OUT
        }
    }

    function pickUniqueRandomSetOfColors(nColors){
        var selectedColors = [];
        var palette = createColorPalette();
        palette = shuffleFisherYates(palette);

        for (i = 0; i < nColors; i++){
            selectedColors[i]= palette[i];
        }

        return selectedColors;
    }

    function shuffleFisherYates(array) {
        var m = array.length, t, i;

        while (m) {
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
        }

        return array;
    }

    function createColorPalette() {
        var colors = [];
        for (var key in experimentColors) {
            colors.push(experimentColors[key]);
        }

       //var colors = ["#FF0000", "#0000FF", "#00FF00", "#CC0000", "#0000CC", "#00CC00", "#FFFF00", "#FF00FF", "#00FFFF", "#FFCC00", "#CC00FF", "#00FFCC"];
       return colors;
    }

    function randomColorFromPalette(colorArray) {
        color = colorArray[randInt(0, colorArray.length)];
        return color;
    }

    //Pseudo-class
    var Box = function(x, y, squareSize) {
        this.margin = 4;
        this.x = x;
        this.y = y;
        this.squareSize = squareSize;
        this.w = x - this.margin;
        this.n = y - this.margin;
        this.e = x + this.squareSize + this.margin;
        this.s = y + this.squareSize + this.margin;
        };

    var n_calls = 0;

    function boundingBoxTest(coordinates1, coordinates2, squareSize){

        var isOverlap = false;

        var box1 = new Box(coordinates1[X], coordinates1[Y], squareSize);
        var box2 = new Box(coordinates2[X], coordinates2[Y], squareSize);
    
        isOverlap =    (box1.s < box2.n)
                    || (box1.n > box2.s)
                    || (box1.e < box2.w)
                    || (box1.w > box2.e);

        return isOverlap;
    }
    
    function getCoordinates(requestedSquares) {
        //TODO Implement recursion
       
        var overlap = 0;

        out("requestedsquares".concat(requestedSquares));
        //console.log("Getting coordinates....");
        var inputArray = [];
        var level = nSquares; //TO DO --- depends on the staircase
        for (i = 0; i < level; i++){
            inputArray[i] = i;
        }
        var outputArray = getAllPairwiseCombinations(inputArray);

        var allSquaresValid  = false;
        var coordinates = [];

        var whilecount = 0;

        //Pick initial squares
        for (i = 0; i < requestedSquares; i++) {
            coordinates.push( pickRandom_xy() );
            //out("requesting ".concat(i + 1).concat("th square"));
        }

        while (allSquaresValid == false) {
            
            out("looping".concat(whilecount++));

            var pair1 = [];
            var pair2 = [];


            overlap = 0;

            for ( j = 0; j < (outputArray.length - 1); j = j + 2) {
                pair1 = coordinates[outputArray[j]];
                pair2 = coordinates[outputArray[j+1]];
                //out(pair1);
                //out(pair2);
                if (boundingBoxTest( pair1, pair2, squareSize )) {
                    out("SUCCESS");                    
                } else {
                    out("BOX overlaps.");
                    overlap++;
                    coordinates[outputArray[j+1]] = pickRandom_xy();
                }
            }
            if (overlap == 0) {
                allSquaresValid = true;
            }
        }
        return coordinates;
    }

    function pickRandom_xy() {
      //  console.log("retrieving random x and y");
        x = randInt(xsquareSize,(600-3*xsquareSize));
        y = randInt(ysquareSize,(500-3*ysquareSize));
        return [ x, y];
    } 
    
    function clearCanvas(context, canvas) {
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function randInt(min, max) {
         return Math.floor(Math.random() * (max - min)) + min;
    }

    function out(aString) {
        //Arbritary function for relaying debug information to programmatically selectable outputs
        console.log(aString);
    }

</script>

</body>
</html>


